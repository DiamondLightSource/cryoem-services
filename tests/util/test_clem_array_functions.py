from __future__ import annotations

import itertools
from typing import Optional

import numpy as np
import pytest

from cryoemservices.util.clem_array_functions import (
    LUT,
    convert_array_dtype,
    convert_to_rgb,
    estimate_int_dtype,
    flatten_image,
    get_dtype_info,
    get_valid_dtypes,
    merge_images,
    shrink_value,
    stretch_image_contrast,
)

known_dtypes = (
    "int8",
    "int16",
    "int32",
    "int64",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "float16",
    "float32",
    "float64",
    "float128",
    "complex64",
    "complex128",
    "complex256",
)


def test_get_valid_dtypes():
    # All known dtypes should be generated by the function
    assert len(set(known_dtypes) - set(get_valid_dtypes())) == 0


@pytest.mark.parametrize("dtype", known_dtypes)
def test_get_dtype_info(dtype: str):

    # Load dtype info from NumPy
    dtype_ref = (
        np.iinfo(dtype) if dtype.startswith(("int", "uint")) else np.finfo(dtype)
    )
    # Load dtype info via function
    dtype_info = get_dtype_info(dtype)

    # Compare the contents of the two objects
    assert (
        len(
            {dtype_info.min, dtype_info.max, str(dtype_info.dtype)}
            - {dtype_ref.min, dtype_ref.max, str(dtype_ref.dtype)}
        )
        == 0
    )


invalid_dtypes = (
    "pneumonoultramicroscopicsilicovolcanoconiosis",
    "supercalifragilisticexpiallidocious",
    "Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch",
    "bool",
    "None",
    "void",
)


@pytest.mark.parametrize("dtype", invalid_dtypes)
def test_get_dtype_info_fails(dtype: str):
    with pytest.raises(ValueError):
        get_dtype_info(dtype)


dtype_estimation_test_matrix = (
    # Min value | Max value | Bit depth (optional) | As float? (bool) | Expected estimate
    # Test bit depth parameter
    (-(2**7), 2**7, 8, True, "int8"),
    (0, 2**7, 16, False, "uint16"),
    (0, 2**8, 32, True, "uint32"),
    (-(2**7), 2**7, 64, False, "int64"),
    # Test auto-find ability
    (0, 2**7, None, False, "uint8"),
    (-(2**15), 2**15, None, True, "int16"),
    (-(2**31), 2**31, None, False, "int32"),
    (0, 2**63, None, True, "uint64"),
)


@pytest.mark.parametrize("test_params", dtype_estimation_test_matrix)
def test_estimate_int_dtype(test_params: tuple[int, int, Optional[int], bool, str]):
    vmin, vmax, bits, is_float, target = test_params

    # Create test array
    shape = (64, 64)
    dtype = "float64" if is_float is True else "int64"
    arr = np.random.randint(vmin, vmax, shape).astype(dtype)

    estimate = estimate_int_dtype(arr, bits)
    assert estimate == target


dtype_estimation_fail_cases = (
    # Min value | Max value | Multiplier | dtype | Bit depth (optional)
    (
        -(2**63),
        2**63,
        2**64,
        "float64",
        256,
    ),  # Fails due to being too big for int dtype
    (
        -(2**63),
        2**63,
        1,
        "complex128",
        None,
    ),  # Fails due to having an imaginary component
)


@pytest.mark.parametrize("test_params", dtype_estimation_fail_cases)
def test_estimate_int_dtype_fails(
    test_params: tuple[int, int, int, str, Optional[int]]
):
    with pytest.raises((ValueError, NotImplementedError)):
        # Unpack parameters
        vmin, vmax, mult, dtype, bits = test_params

        shape = (64, 64)
        # Create array with values that exceed that of the initial 'int64' limits
        arr = (np.random.randint(vmin, vmax, shape).astype("float64") * mult).astype(
            dtype
        )
        if dtype.startswith("complex"):
            # Add an imaginary bit to test
            arr.imag = np.random.randint(vmin, vmax, shape).astype("float64") * mult

        estimate_int_dtype(arr, bits)


shrink_value_pass_cases = tuple(
    sorted(
        set(
            itertools.chain.from_iterable(
                [
                    itertools.chain.from_iterable(
                        [-value, value]
                        for value in (
                            get_dtype_info(dtype).min,
                            get_dtype_info(dtype).max,
                        )
                    )
                    for dtype in known_dtypes
                    if dtype.startswith(("int", "uint"))
                ]
            )
        )
    )
)


@pytest.mark.parametrize("value", shrink_value_pass_cases)
def test_shrink_value(value: int):
    v_new = shrink_value(value)
    assert abs(float(v_new)) <= abs(value)


shrink_value_fail_cases = tuple(
    sorted(
        set(
            itertools.chain.from_iterable(
                [
                    itertools.chain.from_iterable(
                        [-value, value]
                        for value in (
                            get_dtype_info(dtype).min,
                            get_dtype_info(dtype).max,
                        )
                    )
                    for dtype in known_dtypes
                    if not dtype.startswith(("int", "uint"))
                ]
            )
        )
    )
)


@pytest.mark.parametrize("value", shrink_value_fail_cases)
def test_shrink_value_fails(value: float):
    with pytest.raises(TypeError):
        shrink_value(value)


array_conversion_test_matrix = (
    # Starting dtype | Target dtype | Estimate initial dtype?
    # Float -> int/uint
    ("float64", "int8", True),
    ("float32", "int16", False),
    ("float64", "int32", False),
    ("float32", "int64", True),
    ("float32", "uint8", False),
    ("float64", "uint16", True),
    ("float32", "uint32", True),
    ("float64", "uint64", False),
    # int -> int/uint
    ("int64", "int8", False),
    ("int32", "int16", True),
    ("int16", "int32", False),
    ("int8", "int64", True),
    ("int32", "uint8", True),
    ("int64", "uint16", False),
    ("int8", "uint32", True),
    ("int16", "uint64", False),
    # uint -> int/uint
    ("uint32", "int8", True),
    ("uint64", "int16", False),
    ("uint8", "int32", True),
    ("uint16", "int64", False),
    ("uint64", "uint8", False),
    ("uint32", "uint16", True),
    ("uint16", "uint32", False),
    ("uint8", "uint64", True),
    # Wrong initial dtypes
    ("float32", "int8", True),
    ("float64", "int16", False),
    ("complex64", "int32", True),
    ("complex128", "int64", False),
    ("float64", "uint8", False),
    ("float32", "uint16", True),
    ("complex128", "uint32", False),
    ("complex64", "uint64", True),
)


@pytest.mark.parametrize("test_params", array_conversion_test_matrix)
def test_convert_array_dtype(test_params: tuple[str, str, bool]):

    def normalize(arr: np.ndarray) -> np.ndarray:
        diff = arr.max() - arr.min()
        return (arr / diff) - (arr.min() / diff)

    # Get dtype parameters
    dtype_0, dtype_1, estimate = test_params
    info_0 = get_dtype_info(dtype_0)
    info_1 = get_dtype_info(dtype_1)
    shape = (16, 16)

    if dtype_0.startswith(("int", "uint")):
        # Use half range of starting array
        # (np.random.randint uses "int64" by default, so "uint64"'s max value will
        # exceed it)
        vmin = int(0.5 * info_0.min)
        vmax = int(0.5 * info_0.max)
        arr_0 = np.random.randint(vmin, vmax, size=shape).astype(dtype_0)
    else:
        # Use half the integer range of target dtype if starting with float
        vmin = int(0.5 * info_1.min)
        vmax = int(0.5 * info_1.max)
        arr_0 = np.random.randint(vmin, vmax, size=shape).astype(dtype_0)

    # Convert the array using the function
    initial_dtype = estimate_int_dtype(arr_0) if estimate is True else None
    arr_1 = convert_array_dtype(arr_0, dtype_1, initial_dtype)

    # Normalise both arrays to (0, 1) for comparison
    arr_0 = normalize(arr_0)
    arr_1 = normalize(arr_1)

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        arr_1,
        arr_0,
        rtol=0,
        atol=0.01,  # <= 1% deviation when going between 64- and 8-bit arrays
    )


array_conversion_fail_cases = (
    # Image type | Frames | Initial dtype | Target dtype
    # Wrong final dyptes
    ("gray", 5, "int64", "complex128"),
    ("gray", 1, "uint32", "complex128"),
    ("gray", 5, "int16", "float64"),
    ("gray", 1, "uint8", "complex128"),
    ("rgb", 5, "float64", "complex128"),
    ("rgb", 1, "complex128", "float64"),
)


@pytest.mark.parametrize("test_params", array_conversion_fail_cases)
def test_convert_array_dtype_wrong_dtype(test_params: tuple[str, int, str, str]):
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    with pytest.raises((ValueError, NotImplementedError)):
        # Unpack parameters
        img_type, frames, dtype_init, dtype_final = test_params

        # Create a test array
        shape = (64, 64) if img_type == "gray" else (64, 64, 3)
        arr = create_test_array(shape, frames, dtype_init)

        convert_array_dtype(
            array=arr,
            target_dtype=dtype_final,
            initial_dtype=dtype_init,
        )
        pass


contrast_stretching_test_matrix = (
    # Image type | dtype | Frames | Range
    # Test for grayscale images/stacks
    ("gray", "uint8", 1, (0, 100)),
    ("gray", "uint16", 5, (0, 100)),
    ("gray", "uint32", 1, (5, 95)),
    ("gray", "uint64", 5, (5, 95)),
    ("gray", "int8", 1, (0, 100)),
    ("gray", "int16", 5, (0, 100)),
    ("gray", "int32", 1, (5, 95)),
    ("gray", "int64", 5, (5, 95)),
    # Test for RGB images/stacks
    ("rgb", "uint8", 5, (5, 95)),
    ("rgb", "uint16", 1, (0, 100)),
    ("rgb", "uint32", 5, (5, 95)),
    ("rgb", "uint64", 1, (0, 100)),
    ("rgb", "int8", 5, (5, 95)),
    ("rgb", "int16", 1, (0, 100)),
    ("rgb", "int32", 5, (5, 95)),
    ("rgb", "int64", 1, (0, 100)),
)


@pytest.mark.parametrize("test_params", contrast_stretching_test_matrix)
def test_stretch_image_contrast(
    test_params: tuple[str, str, int, tuple[int | float, int | float]]
):

    # Helper function to create arrays
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        dtype_info = get_dtype_info(dtype)
        # Avoid overflow errors due to uint64's max exceeding int64's
        vmin = int(0.5 * dtype_info.min)
        vmax = int(0.5 * dtype_info.max)
        for f in range(frames):
            frame = np.random.randint(vmin, vmax, shape)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        arr = arr.astype(dtype)
        return arr

    def normalize(arr: np.ndarray) -> np.ndarray:
        vmin = float(arr.min())
        vmax = float(arr.max())
        diff = vmax - vmin

        # Normalise to 0-1
        arr_new = (arr - vmin) / diff
        return arr_new

    # Unpack test params
    img_type, dtype, frames, percentile = test_params

    # Determine shape of single frame
    if img_type == "gray":
        shape: tuple[int, ...] = (64, 64)
    elif img_type == "rgb":
        shape = (64, 64, 3)
    else:
        raise ValueError("Unxpected value for image type")

    # Create test array and reference array
    arr = create_test_array(shape, frames, dtype)
    arr_ref = arr.copy()  # Make a copy
    arr_new = stretch_image_contrast(
        arr,
        percentile,
        debug=True,  # Test the debug flag along the way
    )

    # Truncate the reference array and compare it to the test array
    p_lo, p_hi = percentile
    b_lo, b_hi = np.percentile(arr_ref, p_lo), np.percentile(arr_ref, p_hi)

    arr_ref[arr_ref <= b_lo] = b_lo
    arr_ref[arr_ref >= b_hi] = b_hi

    # Normalise both arrays and compare results
    arr_new = normalize(arr_new)
    arr_ref = normalize(arr_ref)

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        arr_new,
        arr_ref,
        atol=0.005,  # Pixel values should be within 0.5% of each other, given the different normalisation routes used
        rtol=0,
    )


image_coloring_fail_cases = (
    ("black", "uint8", 1),
    ("white", "int16", 5),
    ("orange", "uint32", 1),
    ("indigo", "int64", 5),
    ("violet", "float64", 1),
    ("pneumonoultramicroscopicsilicovolcanoconiosis", "complex128", 5),
)


@pytest.mark.parametrize("test_params", image_coloring_fail_cases)
def test_convert_to_rgb_fails(test_params: tuple[str, str, int]):
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    # The colours should throw up an error
    with pytest.raises(KeyError):
        # Unpack parameters
        color, dtype, frames = test_params
        shape = (64, 64)
        arr = create_test_array(shape, frames, dtype)

        convert_to_rgb(arr, color)


image_coloring_test_matrix = (
    # Colour | dtype | frames
    ("red", "uint8", 1),
    ("green", "int16", 5),
    ("blue", "uint32", 1),
    ("cyan", "int64", 5),
    ("magenta", "float16", 1),
    ("yellow", "float32", 5),
    ("gray", "float64", 1),
    ("red", "float128", 5),
    ("green", "complex64", 1),
    ("blue", "complex128", 5),
    ("cyan", "complex256", 1),
    ("magenta", "complex64", 5),
    ("yellow", "complex128", 1),
    ("gray", "complex256", 5),
    ("red", "float16", 1),
    ("green", "float32", 5),
    ("blue", "float64", 1),
    ("cyan", "float128", 5),
    ("magenta", "int8", 1),
    ("yellow", "uint16", 5),
    ("gray", "int32", 1),
)


@pytest.mark.parametrize("test_params", image_coloring_test_matrix)
def test_convert_to_rgb(test_params: tuple[str, str, int]):

    def create_test_array(shape: tuple, frames: int, dtype: str):
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    # Unpack parameters
    color, dtype, frames = test_params

    # Create test grayscale array
    shape = (64, 64)
    shape_new = (frames, *shape, 3)
    arr = create_test_array(shape, frames, dtype)

    # Test both success and failure conditions
    arr_new = convert_to_rgb(arr, color)

    # Check that array has expected properties
    assert arr_new.shape == shape_new
    assert str(arr_new.dtype) == dtype

    # Check that RGB values have been applied correctly
    pixel_values = np.array(LUT[color].value).astype(dtype)
    assert np.all(arr_new[0][0][0] == pixel_values)


image_flattening_test_matrix = (
    # Type | Frames | Mode | Is float? | Expected pixel value
    # Test grayscale images
    ("gray", 5, "mean", True, 2),
    ("gray", 5, "min", False, 0),
    ("gray", 5, "max", True, 4),
    ("gray", 5, None, True, 2),
    # Test RGB images
    ("rgb", 5, "mean", False, 2),
    ("rgb", 5, "min", True, 0),
    ("rgb", 5, "max", False, 4),
    ("rgb", 5, None, False, 2),
)


@pytest.mark.parametrize("test_params", image_flattening_test_matrix)
def test_flatten_image(test_params: tuple[str, int, Optional[str], bool, int]):

    # Helper function to create an array simulating an image stack
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            # Increment array values by 1 per frame
            frame = np.ones(shape).astype(dtype) * f
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    # Unpack test parameters
    img_type, frames, mode, is_float, result = test_params

    # Choose "int" and "float" dtypes
    dtype = "float64" if is_float is True else "int64"

    # Choose between grayscale or RGB image
    if img_type == "gray":
        shape: tuple[int, ...] = (64, 64)
    elif img_type == "rgb":
        shape = (64, 64, 3)
    else:
        raise ValueError("Unexpected value for image type")

    # Create image stack and flatten it
    arr = create_test_array(shape, frames, dtype)
    arr_new = flatten_image(arr, mode) if isinstance(mode, str) else flatten_image(arr)

    # Create new flattened array with the expected pixel value
    #   Because pixel values increase from 0 to (frame - 1) per frame, it's possible
    #   to predict what the array values will be after flattening using "mean", "max",
    #   or "min".
    arr_ref = np.ones(shape).astype(dtype) * result
    # DEBUG: Check that reference array has expected properties
    assert np.all(arr_ref == result) and arr_ref.shape == shape

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        arr_new,
        arr_ref,
        rtol=0,
        atol=1e-20,  # Really, there shouldn't be a difference
    )


image_flattening_fail_cases: tuple[tuple, ...] = (
    # Image type | Frames | Mode | Is float?
    ("gray", 5, "uvuvwevwevwe", True),
    ("gray", 5, "onyetenyevwe", False),
    ("gray", 5, "ugwemubwem", True),
    ("rgb", 5, "osas", False),
    ("rgb", 5, 5, True),
    ("rgb", 5, True, False),
    ("rgb", 5, [], True),
    ("rgb", 5, (), True),
    ("rgb", 5, {}, True),
    ("rgb", 5, set(), True),
)


@pytest.mark.parametrize("test_params", image_flattening_fail_cases)
def test_flatten_image_fails(
    test_params: tuple[str, int, str | int | bool | list | tuple | dict | set, bool]
):

    # Helper function to create an array simulating an image stack
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            # Increment array values by 1 per frame
            frame = np.ones(shape).astype(dtype) * f
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    with pytest.raises(ValueError):
        # Unpack parameters
        img_type, frames, mode, is_float = test_params
        shape = (64, 64) if img_type == "gray" else (64, 64, 3)
        dtype = "float64" if is_float is True else "int64"

        arr = create_test_array(shape, frames, dtype)
        flatten_image(arr, mode)


image_merging_test_matrix = (
    # Type | No. images | Frames | Is float? | Expected pixel value*
    #   * NOTE: np.round rounds to the nearest EVEN number for values
    #   EXACTLY halfway between rounded decimal values (e.g. 0.5
    #   rounds to 0, -1.5 rounds to -2, etc.).
    # Test grayscale stacks
    ("gray", 1, 5, False, 0),
    ("gray", 2, 5, True, 0.5),
    ("gray", 3, 5, True, 1),
    ("gray", 4, 5, False, 2),
    # Test RGB stacks
    ("rgb", 1, 5, True, 0),
    ("rgb", 2, 5, False, 0),
    ("rgb", 3, 5, False, 1),
    ("rgb", 4, 5, True, 1.5),
    # Test on images
    ("gray", 1, 1, False, 0),
    ("gray", 2, 1, True, 0.5),
    ("rgb", 3, 1, False, 1),
    ("rgb", 4, 1, True, 1.5),
)


@pytest.mark.parametrize("test_params", image_merging_test_matrix)
def test_merge_images(test_params: tuple[str, int, int, bool, int | float]):

    # Unpack test parameters
    img_type, num_imgs, frames, is_float, result = test_params

    # Select dtype
    dtype = "float64" if is_float is True else "int64"

    # Set frame shape based on grayscale or RGB image
    if img_type == "gray":
        shape: tuple[int, ...] = (64, 64)
    elif img_type == "rgb":
        shape = (64, 64, 3)
    else:
        raise ValueError("Unexpected value for image type")

    # Create list of images/stacks and merge them
    arr_list = []
    for n in range(num_imgs):
        # Increment values by image/stack
        arr = np.array([np.ones(shape) for f in range(frames)]).astype(dtype) * n
        arr_list.append(arr)
    # DEBUG: Check that arrays are generated correctly
    assert all(str(type(arr)) == str(np.ndarray) for arr in arr_list)
    composite = merge_images(arr_list)

    # Create a reference stack to compare against
    #   All values for a single image are the same and increment per image from
    #   0 - (num_img -1), so the expected average value of the final product can be
    #   quickly calculated
    arr_ref = np.array([np.ones(shape) for f in range(frames)]).astype(dtype) * result
    # DEBUG: Check that reference array has the expected shape
    assert arr_ref.shape == (frames, *shape)

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        composite,
        arr_ref,
        rtol=0,
        atol=1e-20,  # Really, there shouldn't be a difference
    )


def test_preprocess_img_stk():
    pass


def test_write_stack_to_tiff():
    pass
