from __future__ import annotations

# import itertools
from typing import Any, Optional

import numpy as np
import pytest

from cryoemservices.util.clem_array_functions import (
    LUT,
    convert_array_dtype,
    convert_to_rgb,
    estimate_int_dtype,
    flatten_image,
    get_dtype_info,
    get_dtype_limits,
    get_valid_dtypes,
    merge_images,
    preprocess_img_stk,
    stretch_image_contrast,
)

known_dtypes = (
    "int8",
    "int16",
    "int32",
    "int64",
    "uint8",
    "uint16",
    "uint32",
    "uint64",
    "float16",
    "float32",
    "float64",
    "float128",
    "complex64",
    "complex128",
    "complex256",
)


def test_get_valid_dtypes():
    # All known dtypes should be generated by the function
    assert len(set(known_dtypes) - set(get_valid_dtypes())) == 0


@pytest.mark.parametrize("dtype", known_dtypes)
def test_get_dtype_info(dtype: str):

    # Load dtype info from NumPy
    dtype_ref = (
        np.iinfo(dtype) if dtype.startswith(("int", "uint")) else np.finfo(dtype)
    )
    # Load dtype info via function
    dtype_info = get_dtype_info(dtype)

    # Compare the contents of the two objects
    assert (
        len(
            {dtype_info.min, dtype_info.max, str(dtype_info.dtype)}
            - {dtype_ref.min, dtype_ref.max, str(dtype_ref.dtype)}
        )
        == 0
    )


invalid_dtypes = (
    "pneumonoultramicroscopicsilicovolcanoconiosis",
    "supercalifragilisticexpiallidocious",
    "Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch",
    "bool",
    "None",
    "void",
)


@pytest.mark.parametrize("dtype", invalid_dtypes)
def test_get_dtype_info_fails(dtype: str):
    with pytest.raises(ValueError):
        get_dtype_info(dtype)


dtype_limits_test_matrix = (
    # dtype | Expected min | Expected max
    ("int8", -(2**7), (2**7) - 1),
    ("int16", -(2**15), (2**15) - 1),
    ("int32", -(2**31), (2**31) - 1),
    ("int64", -(2**51), (2**51)),  # Use safe integer casting limit
    ("uint8", 0, (2**8) - 1),
    ("uint16", 0, (2**16) - 1),
    ("uint32", 0, (2**32) - 1),
    ("uint64", 0, (2**51)),  # Use safe integer casting limit
    ("float16", -(2**10), 2**10),  # Use safe casting limit
    ("float32", -(2**23), (2**23)),  # Use safe integer casting limit
    ("float64", -(2**51), (2**51)),  # Use safe integer casting limit
    ("float128", -(2**51), (2**51)),  # Use safe integer casting limit
    ("complex64", -(2**23), (2**23)),  # Use safe integer casting limit
    ("complex128", -(2**51), (2**51)),  # Use safe integer casting limit
    ("complex256", -(2**51), (2**51)),  # Use safe integer casting limit
)


@pytest.mark.parametrize("test_params", dtype_limits_test_matrix)
def test_get_dtype_limits(test_params: tuple[str, int, int]):
    # Unpack test parameters
    dtype, vmin, vmax = test_params
    limits = get_dtype_limits(dtype)
    assert limits.min == vmin and limits.max == vmax


dtype_estimation_test_matrix = (
    # Min value | Max value | Bit depth (optional) | As float? (bool) | Expected estimate
    # Test bit depth parameter
    (-(2**7), 2**7 - 1, 8, True, "int8"),
    (-(2**7), 2**7 - 1, 16, False, "int16"),
    (-(2**7), 2**7 - 1, 32, True, "int32"),
    (-(2**7), 2**7 - 1, 64, True, "int64"),
    (0, 2**7 - 1, 8, False, "uint8"),
    (0, 2**7 - 1, 16, True, "uint16"),
    (0, 2**7 - 1, 32, False, "uint32"),
    (0, 2**7 - 1, 64, False, "uint64"),
    # Test auto-find ability
    (0, 2**8 - 1, None, False, "uint8"),
    (0, 2**16 - 1, None, True, "uint16"),
    (0, 2**32 - 1, None, False, "uint32"),
    (0, 2**51, None, True, "uint64"),
    (-(2**7), 2**7 - 1, None, True, "int8"),
    (-(2**15), 2**15 - 1, None, True, "int16"),
    (-(2**31), 2**31 - 1, None, False, "int32"),
    (-(2**51), 2**51, None, True, "int64"),
)


@pytest.mark.parametrize("test_params", dtype_estimation_test_matrix)
def test_estimate_int_dtype(test_params: tuple[int, int, Optional[int], bool, str]):
    vmin, vmax, bits, is_float, target = test_params

    # Create test array
    shape = (64, 64)
    dtype = "float64" if is_float is True else "int64"
    # Create test array with numbers spanning the range provided
    arr = np.reshape(np.linspace(vmin, vmax, np.prod(shape)), shape).astype(dtype)

    estimate = estimate_int_dtype(arr, bits)
    assert estimate == target


dtype_estimation_fail_cases = (
    # Min value | Max value | Multiplier | dtype | Bit depth (optional)
    (
        -(2**63),
        2**63,
        2**64,
        "float64",
        256,
    ),  # Fails due to being too big for int dtype
    (
        -(2**63),
        2**63,
        1,
        "complex128",
        None,
    ),  # Fails due to having an imaginary component
)


@pytest.mark.parametrize("test_params", dtype_estimation_fail_cases)
def test_estimate_int_dtype_fails(
    test_params: tuple[int, int, int, str, Optional[int]]
):
    with pytest.raises((ValueError, NotImplementedError)):
        # Unpack parameters
        vmin, vmax, mult, dtype, bits = test_params

        shape = (64, 64)
        # Create array with values that exceed that of the initial 'int64' limits
        arr = (
            np.reshape(np.linspace(vmin, vmax, np.prod(shape)), shape).astype("float64")
            * mult
        ).astype(dtype)
        if dtype.startswith("complex"):
            # Add an imaginary bit to test
            arr.imag = (
                np.reshape(np.linspace(vmin, vmax, np.prod(shape)), shape).astype(
                    "float64"
                )
                * mult
            )
        estimate_int_dtype(arr, bits)


array_conversion_test_matrix = (
    # Starting dtype | Target dtype | Estimate initial dtype? | Starting values
    # float128 -> int/uint
    ("float128", "int8", True, (-(2**51), (2**51))),  # Simulate int64
    ("float128", "int8", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float128", "int8", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float128", "int8", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float128", "int8", False, (0, (2**51))),  # Simulate uint64
    ("float128", "int8", True, (0, (2**31) - 1)),  # Simulate uint32
    ("float128", "int8", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float128", "int8", False, (0, (2**7) - 1)),  # Simulate uint8
    ("float128", "int32", True, (-(2**51), (2**51))),  # Simulate int64
    ("float128", "int32", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float128", "int32", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float128", "int32", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float128", "int32", False, (0, (2**51))),  # Simulate uint64
    ("float128", "int32", True, (0, (2**31) - 1)),  # Simulate uint32
    ("float128", "int32", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float128", "int32", False, (0, (2**7) - 1)),  # Simulate uint8
    ("float128", "uint16", True, (-(2**51), (2**51))),  # Simulate int64
    ("float128", "uint16", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float128", "uint16", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float128", "uint16", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float128", "uint16", False, (0, (2**51))),  # Simulate uint64
    ("float128", "uint16", True, (0, (2**31) - 1)),  # Simulate uint32
    ("float128", "uint16", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float128", "uint16", False, (0, (2**7) - 1)),  # Simulate uint8
    ("float128", "uint64", True, (-(2**51), (2**51))),  # Simulate int64
    ("float128", "uint64", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float128", "uint64", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float128", "uint64", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float128", "uint64", False, (0, (2**51))),  # Simulate uint64
    ("float128", "uint64", True, (0, (2**31) - 1)),  # Simulate uint32
    ("float128", "uint64", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float128", "uint64", False, (0, (2**7) - 1)),  # Simulate uint8
    # float64 -> int/uint
    ("float64", "int16", True, (-(2**51), (2**51))),  # Simulate int64
    ("float64", "int16", True, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float64", "int16", False, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float64", "int16", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float64", "int16", True, (0, (2**51))),  # Simulate uint64
    ("float64", "int16", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float64", "int16", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float64", "int16", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float64", "int64", True, (-(2**51), (2**51))),  # Simulate int64
    ("float64", "int64", True, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float64", "int64", False, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float64", "int64", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float64", "int64", True, (0, (2**51))),  # Simulate uint64
    ("float64", "int64", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float64", "int64", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float64", "int64", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float64", "uint8", True, (-(2**51), (2**51))),  # Simulate int64
    ("float64", "uint8", True, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float64", "uint8", False, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float64", "uint8", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float64", "uint8", True, (0, (2**51))),  # Simulate uint64
    ("float64", "uint8", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float64", "uint8", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float64", "uint8", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float64", "uint32", True, (-(2**51), (2**51))),  # Simulate int64
    ("float64", "uint32", True, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("float64", "uint32", False, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("float64", "uint32", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float64", "uint32", True, (0, (2**51))),  # Simulate uint64
    ("float64", "uint32", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float64", "uint32", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float64", "uint32", True, (0, (2**7) - 1)),  # Simulate uint8
    # float32 -> int/uint
    ("float32", "int8", False, (-(2**15), (2**15) - 2)),  # Simulate int16
    ("float32", "int8", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float32", "int8", True, (0, (2**51))),  # Simulate uint64
    ("float32", "int8", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float32", "int8", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float32", "int8", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float32", "int16", False, (-(2**15), (2**15) - 2)),  # Simulate int16
    ("float32", "int16", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float32", "int16", True, (0, (2**51))),  # Simulate uint64
    ("float32", "int16", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float32", "int16", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float32", "int16", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float32", "uint32", False, (-(2**15), (2**15) - 2)),  # Simulate int16
    ("float32", "uint32", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float32", "uint32", True, (0, (2**51))),  # Simulate uint64
    ("float32", "uint32", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float32", "uint32", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float32", "uint32", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float32", "uint64", False, (-(2**15), (2**15) - 2)),  # Simulate int16
    ("float32", "uint64", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float32", "uint64", True, (0, (2**51))),  # Simulate uint64
    ("float32", "uint64", False, (0, (2**31) - 1)),  # Simulate uint32
    ("float32", "uint64", True, (0, (2**15) - 1)),  # Simulate uint16
    ("float32", "uint64", True, (0, (2**7) - 1)),  # Simulate uint8
    # float16 -> int/uint
    ("float16", "int16", False, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float16", "int16", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float16", "int32", False, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float16", "int32", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float16", "uint8", False, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float16", "uint8", True, (0, (2**7) - 1)),  # Simulate uint8
    ("float16", "uint64", False, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("float16", "uint64", True, (0, (2**7) - 1)),  # Simulate uint8
    # int/uint -> int/uint
    ("int64", "int8", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "int8", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "int8", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "int8", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("int64", "int16", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "int16", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "int16", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "int16", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("uint64", "int32", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "int32", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "int32", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "int32", False, (0, (2**7) - 1)),  # Simulate uint8
    ("uint64", "int64", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "int64", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "int64", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "int64", False, (0, (2**7) - 1)),  # Simulate uint8
    # int/uint -> float/complex
    ("int64", "float16", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "float16", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "float16", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "float16", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("int64", "float32", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "float32", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "float32", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "float32", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("uint64", "float64", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "float64", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "float64", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "float64", False, (0, (2**7) - 1)),  # Simulate uint8
    ("uint64", "float128", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "float128", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "float128", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "float128", False, (0, (2**7) - 1)),  # Simulate uint8
    ("int64", "complex64", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "complex64", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "complex64", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "complex64", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("int64", "complex128", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "complex128", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "complex128", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "complex128", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("int64", "complex256", True, (-(2**51), (2**51))),  # Simulate int64
    ("int32", "complex256", False, (-(2**31), (2**31) - 1)),  # Simulate int32
    ("int16", "complex256", True, (-(2**15), (2**15) - 1)),  # Simulate int16
    ("int8", "complex256", True, (-(2**7), (2**7) - 1)),  # Simulate int8
    ("uint64", "complex64", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "complex64", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "complex64", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "complex64", False, (0, (2**7) - 1)),  # Simulate uint8
    ("uint64", "complex128", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "complex128", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "complex128", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "complex128", False, (0, (2**7) - 1)),  # Simulate uint8
    ("uint64", "complex256", False, (0, (2**51))),  # Simulate uint64
    ("uint32", "complex256", True, (0, (2**31) - 1)),  # Simulate uint32
    ("uint16", "complex256", True, (0, (2**15) - 1)),  # Simulate uint16
    ("uint8", "complex256", False, (0, (2**7) - 1)),  # Simulate uint8
)


@pytest.mark.parametrize("test_params", array_conversion_test_matrix)
def test_convert_array_dtype(test_params: tuple[str, str, bool, tuple[int, int]]):

    def normalize(arr: np.ndarray) -> np.ndarray:
        if str(arr.dtype).startswith("complex"):
            arr = arr.real
        diff = float(arr.max()) - float(arr.min())
        arr_new = (arr / diff) - (arr.min() / diff)
        return arr_new

    # Get dtype parameters
    dtype_init, dtype_final, estimate, (vmin, vmax) = test_params
    shape = (64, 64)

    # Create test array with numbers going throughout the specified range
    arr_ref = np.reshape(np.linspace(vmin, vmax, np.prod(shape)), shape).astype(
        dtype_init
    )

    # Convert the array using the function
    dtype_estimate = None if estimate is True else dtype_init
    arr_new = convert_array_dtype(arr_ref, dtype_final, dtype_estimate)

    # Check that target dtype is attained
    assert str(arr_new.dtype) == dtype_final

    # Normalise both arrays to (0, 1) for comparison
    arr_ref = normalize(arr_ref)
    arr_new = normalize(arr_new)

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        arr_new,
        arr_ref,
        rtol=0,
        atol=0.01,  # <= 1% deviation when going between 128- and 8-bit arrays
    )


array_conversion_fail_cases = (
    # Image type | Frames | Initial dtype | Target dtype
    # Wrong final dyptes
    ("rgb", 1, "complex128", "float64"),
    (
        "rgb",
        1,
        "complex128",
        "TaumatawhakatangihangakoauauoTamateaturipukakapikimaungahoronukupokaiwhenuakitanatahu",
    ),
    ("rgb", 5, "float64", "Chargoggagoggmanchauggagoggchaubunagungamaugg"),
    ("rgb", 1, "complex128", "uint8"),
)


# @pytest.mark.skip
@pytest.mark.parametrize("test_params", array_conversion_fail_cases)
def test_convert_array_dtype_wrong_dtype(test_params: tuple[str, int, str, str]):
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    with pytest.raises((ValueError, NotImplementedError)):
        # Unpack parameters
        img_type, frames, dtype_init, dtype_final = test_params

        # Create a test array
        shape = (64, 64) if img_type == "gray" else (64, 64, 3)

        # Replace illogical dtypes with valid ones when creating the test array
        dtype = dtype_init if dtype_init in get_valid_dtypes() else "float64"
        arr = create_test_array(shape, frames, dtype)
        if str(arr.dtype).startswith("complex"):
            arr.imag = create_test_array(shape, frames, "float64")

        convert_array_dtype(
            array=arr,
            target_dtype=dtype_final,
            initial_dtype=dtype_init,
        )


contrast_stretching_test_matrix = (
    # Image type | dtype | Target dtype | Frames | Range
    # Test for grayscale images/stacks
    ("gray", "uint8", "uint8", 1, (0, 100)),
    ("gray", "uint16", "uint32", 5, (0, 100)),
    ("gray", "uint32", None, 1, (5, 95)),
    ("gray", "uint64", "uint64", 5, (5, 95)),
    ("gray", "int8", "int8", 1, (0, 100)),
    ("gray", "int16", None, 5, (0, 100)),
    ("gray", "int32", "int32", 1, (5, 95)),
    ("gray", "int64", "int64", 5, (5, 95)),
    # Test for RGB images/stacks
    ("rgb", "uint8", None, 5, (5, 95)),
    ("rgb", "uint16", "uint8", 1, (0, 100)),
    ("rgb", "uint32", "uint32", 5, (5, 95)),
    ("rgb", "uint64", None, 1, (0, 100)),
    ("rgb", "int8", "int8", 5, (5, 95)),
    ("rgb", "int16", "int32", 1, (0, 100)),
    ("rgb", "int32", None, 5, (5, 95)),
    ("rgb", "int64", "int64", 1, (0, 100)),
    # Test for float and complex starting arrays
    ("gray", "float64", "uint8", 1, (0, 100)),
    ("gray", "complex128", "uint16", 5, (0, 100)),
    ("rgb", "float64", "uint32", 1, (5, 95)),
    ("rgb", "complex128", "uint64", 5, (5, 95)),
    # Test for float and complex target dtypes
    ("gray", "int8", "float16", 1, (0, 100)),
    ("gray", "int16", "float64", 5, (0, 100)),
    ("gray", "uint32", "complex128", 1, (5, 95)),
    ("gray", "uint64", "complex256", 5, (5, 95)),
)


@pytest.mark.parametrize("test_params", contrast_stretching_test_matrix)
def test_stretch_image_contrast(
    test_params: tuple[str, str, Optional[str], int, tuple[int | float, int | float]]
):

    # Helper function to create arrays
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        limits = get_dtype_limits(dtype)
        vmin = limits.min
        vmax = limits.max
        arr = np.reshape(
            np.linspace(vmin, vmax, np.prod((frames, *shape))), (frames, *shape)
        ).astype(dtype)
        return arr

    def normalize(arr: np.ndarray) -> np.ndarray:
        if str(arr.dtype).startswith("complex"):
            arr = arr.real
        vmin = float(arr.min())
        vmax = float(arr.max())
        diff = vmax - vmin

        # Normalise to 0-1
        arr_new = (arr - vmin) / diff
        return arr_new

    # Unpack test params
    img_type, dtype, target_dtype, frames, percentile = test_params

    # Determine shape of single frame
    if img_type == "gray":
        shape: tuple[int, ...] = (64, 64)
    elif img_type == "rgb":
        shape = (64, 64, 3)
    else:
        raise ValueError("Unxpected value for image type")

    # Create test array and reference array
    arr = (
        create_test_array(shape, frames, target_dtype)
        if target_dtype is not None
        else create_test_array(shape, frames, dtype)
    )
    arr_ref = arr.copy()  # Make a copy
    arr_new = (
        stretch_image_contrast(
            arr,
            percentile,
            target_dtype=target_dtype,
            debug=True,
        )
        if target_dtype is not None
        else stretch_image_contrast(
            arr,
            percentile,
            debug=True,  # Test the debug flag along the way
        )
    )

    # Keep real parts of the complex array
    if str(arr_ref.dtype).startswith("complex"):
        arr_ref = arr_ref.real
    # Truncate the reference array and compare it to the test array
    p_lo, p_hi = percentile
    b_lo, b_hi = np.percentile(arr_ref, p_lo), np.percentile(arr_ref, p_hi)

    arr_ref[arr_ref <= b_lo] = b_lo
    arr_ref[arr_ref >= b_hi] = b_hi

    # Normalise both arrays and compare results
    arr_new = normalize(arr_new)
    arr_ref = normalize(arr_ref)

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        arr_new,
        arr_ref,
        atol=0.005,  # Pixel values should be within 0.5% of each other, given the different normalisation routes used
        rtol=0,
    )


contrast_stretching_fail_cases = (
    # Array dtype | Target dtype
    ("complex128", None),
    ("complex128", "complex128"),
)


# @pytest.mark.skip
@pytest.mark.parametrize("test_params", contrast_stretching_fail_cases)
def test_stretch_image_contrast_fails(test_params: tuple[str, Optional[str]]):
    with pytest.raises((NotImplementedError, ValueError)):
        # Unpack parameters
        dtype, target_dtype = test_params
        shape = (64, 64)
        # Create test array
        arr = np.reshape(np.linspace(0, 255, np.prod(shape)), shape).astype(dtype)
        if dtype.startswith("complex"):
            arr.imag = np.reshape(np.linspace(0, 255, np.prod(shape)), shape).astype(
                "float64"
            )

        # Test function
        if target_dtype is None:
            stretch_image_contrast(arr)
        else:
            stretch_image_contrast(arr, target_dtype=target_dtype)


image_coloring_test_matrix = (
    # Colour | dtype | frames
    ("red", "uint8", 1),
    ("green", "int16", 5),
    ("blue", "uint32", 1),
    ("cyan", "int64", 5),
    ("magenta", "float16", 1),
    ("yellow", "float32", 5),
    ("gray", "float64", 1),
    ("red", "float128", 5),
    ("green", "complex64", 1),
    ("blue", "complex128", 5),
    ("cyan", "complex256", 1),
    ("magenta", "complex64", 5),
    ("yellow", "complex128", 1),
    ("gray", "complex256", 5),
    ("red", "float16", 1),
    ("green", "float32", 5),
    ("blue", "float64", 1),
    ("cyan", "float128", 5),
    ("magenta", "int8", 1),
    ("yellow", "uint16", 5),
    ("gray", "int32", 1),
)


@pytest.mark.parametrize("test_params", image_coloring_test_matrix)
def test_convert_to_rgb(test_params: tuple[str, str, int]):

    def create_test_array(shape: tuple, frames: int, dtype: str):
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    # Unpack parameters
    color, dtype, frames = test_params

    # Create test grayscale array
    shape = (64, 64)
    shape_new = (frames, *shape, 3)
    arr = create_test_array(shape, frames, dtype)

    # Test both success and failure conditions
    arr_new = convert_to_rgb(arr, color)

    # Check that array has expected properties
    assert arr_new.shape == shape_new
    assert str(arr_new.dtype) == dtype

    # Check that RGB values have been applied correctly
    pixel_values = np.array(LUT[color].value).astype(dtype)
    assert np.all(arr_new[0][0][0] == pixel_values)


image_coloring_fail_cases = (
    ("black", "uint8", 1),
    ("white", "int16", 5),
    ("orange", "uint32", 1),
    ("indigo", "int64", 5),
    ("violet", "float64", 1),
    ("pneumonoultramicroscopicsilicovolcanoconiosis", "complex128", 5),
)


@pytest.mark.parametrize("test_params", image_coloring_fail_cases)
def test_convert_to_rgb_fails(test_params: tuple[str, str, int]):
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    # The colours should throw up an error
    with pytest.raises(KeyError):
        # Unpack parameters
        color, dtype, frames = test_params
        shape = (64, 64)
        arr = create_test_array(shape, frames, dtype)

        convert_to_rgb(arr, color)


image_flattening_test_matrix = (
    # Type | Frames | Mode | Is float? | Expected pixel value
    # Test grayscale images
    ("gray", 5, "mean", True, 2),
    ("gray", 5, "min", False, 0),
    ("gray", 5, "max", True, 4),
    ("gray", 5, None, True, 2),
    # Test RGB images
    ("rgb", 5, "mean", False, 2),
    ("rgb", 5, "min", True, 0),
    ("rgb", 5, "max", False, 4),
    ("rgb", 5, None, False, 2),
)


@pytest.mark.parametrize("test_params", image_flattening_test_matrix)
def test_flatten_image(test_params: tuple[str, int, Optional[str], bool, int]):

    # Helper function to create an array simulating an image stack
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            # Increment array values by 1 per frame
            frame = np.ones(shape).astype(dtype) * f
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    # Unpack test parameters
    img_type, frames, mode, is_float, result = test_params

    # Choose "int" and "float" dtypes
    dtype = "float64" if is_float is True else "int64"

    # Choose between grayscale or RGB image
    if img_type == "gray":
        shape: tuple[int, ...] = (64, 64)
    elif img_type == "rgb":
        shape = (64, 64, 3)
    else:
        raise ValueError("Unexpected value for image type")

    # Create image stack and flatten it
    arr = create_test_array(shape, frames, dtype)
    arr_new = flatten_image(arr, mode) if isinstance(mode, str) else flatten_image(arr)

    # Create new flattened array with the expected pixel value
    #   Because pixel values increase from 0 to (frame - 1) per frame, it's possible
    #   to predict what the array values will be after flattening using "mean", "max",
    #   or "min".
    arr_ref = np.ones(shape).astype(dtype) * result
    # DEBUG: Check that reference array has expected properties
    assert np.all(arr_ref == result) and arr_ref.shape == shape

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        arr_new,
        arr_ref,
        rtol=0,
        atol=1e-20,  # Really, there shouldn't be a difference
    )


image_flattening_fail_cases: tuple[tuple, ...] = (
    # Image type | Frames | Mode | Is float?
    ("gray", 5, "uvuvwevwevwe", True),
    ("gray", 5, "onyetenyevwe", False),
    ("gray", 5, "ugwemubwem", True),
    ("rgb", 5, "osas", False),
    ("rgb", 5, 5, True),
    ("rgb", 5, True, False),
    ("rgb", 5, [], True),
    ("rgb", 5, (), True),
    ("rgb", 5, {}, True),
    ("rgb", 5, set(), True),
)


@pytest.mark.parametrize("test_params", image_flattening_fail_cases)
def test_flatten_image_fails(test_params: tuple[str, int, Any, bool]):

    # Helper function to create an array simulating an image stack
    def create_test_array(shape: tuple, frames: int, dtype: str) -> np.ndarray:
        for f in range(frames):
            # Increment array values by 1 per frame
            frame = np.ones(shape).astype(dtype) * f
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    with pytest.raises(ValueError):
        # Unpack parameters
        img_type, frames, mode, is_float = test_params
        shape = (64, 64) if img_type == "gray" else (64, 64, 3)
        dtype = "float64" if is_float is True else "int64"

        arr = create_test_array(shape, frames, dtype)
        flatten_image(arr, mode)


image_merging_test_matrix = (
    # Type | Num images | Frames | Is float? | Expected pixel value*
    #   * NOTE: np.round rounds to the nearest EVEN number for values
    #   EXACTLY halfway between rounded decimal values (e.g. 0.5
    #   rounds to 0, -1.5 rounds to -2, etc.).
    # Test grayscale stacks
    ("gray", 1, 5, False, 0),
    ("gray", 2, 5, True, 0.5),
    ("gray", 3, 5, True, 1),
    ("gray", 4, 5, False, 2),
    # Test RGB stacks
    ("rgb", 1, 5, True, 0),
    ("rgb", 2, 5, False, 0),
    ("rgb", 3, 5, False, 1),
    ("rgb", 4, 5, True, 1.5),
    # Test on images
    ("gray", 1, 1, False, 0),
    ("gray", 2, 1, True, 0.5),
    ("rgb", 3, 1, False, 1),
    ("rgb", 4, 1, True, 1.5),
)


@pytest.mark.parametrize("test_params", image_merging_test_matrix)
def test_merge_images(test_params: tuple[str, int, int, bool, int | float]):

    # Unpack test parameters
    img_type, num_imgs, frames, is_float, result = test_params

    # Select dtype
    dtype = "float64" if is_float is True else "int64"

    # Set frame shape based on grayscale or RGB image
    if img_type == "gray":
        shape: tuple[int, ...] = (64, 64)
    elif img_type == "rgb":
        shape = (64, 64, 3)
    else:
        raise ValueError("Unexpected value for image type")

    # Create list of images/stacks and merge them
    arr_list: np.ndarray | list[np.ndarray] = []
    for n in range(num_imgs):
        # Increment values by image/stack
        arr = np.array([np.ones(shape) for f in range(frames)]).astype(dtype) * n
        if num_imgs == 1:
            arr_list = arr
        else:
            arr_list.append(arr)
    # DEBUG: Check that arrays are generated correctly
    assert all(str(type(arr)) == str(np.ndarray) for arr in arr_list)
    composite = merge_images(arr_list)

    # Create a reference stack to compare against
    #   All values for a single image are the same and increment per image from
    #   0 - (num_img -1), so the expected average value of the final product can be
    #   quickly calculated
    arr_ref = np.array([np.ones(shape) for f in range(frames)]).astype(dtype) * result
    # DEBUG: Check that reference array has the expected shape
    assert arr_ref.shape == (frames, *shape)

    # Check that deviations are within a set threshold:
    # arr_1 - arr_0 = atol + rtol * abs(arr_0)
    np.testing.assert_allclose(
        composite,
        arr_ref,
        rtol=0,
        atol=1e-20,  # Really, there shouldn't be a difference
    )


image_merging_fail_cases = (
    # Image type | Num images | Same frames? | Same size? | Same dtype?
    ("gray", 2, False, True, False),
    ("gray", 3, True, True, False),
    ("gray", 4, False, True, True),
    ("rgb", 2, True, False, True),
    ("rgb", 3, False, False, True),
    ("rgb", 4, True, False, False),
)


@pytest.mark.parametrize("test_params", image_merging_fail_cases)
def test_merge_images_fails(test_params: tuple[str, int, bool, bool, bool]):

    def create_test_array(shape, frames, dtype):
        for f in range(frames):
            frame = np.ones(shape).astype(dtype)
            if f == 0:
                arr = np.array([frame])
            else:
                arr = np.append(arr, [frame], axis=0)
        return arr

    with pytest.raises(ValueError):
        # Unpack test_params
        img_type, num_images, frames, size, dtypes = test_params

        # Create list of test arrays
        arr_list: list[np.ndarray] = []
        for i in range(num_images):
            shape: tuple[int, ...] = (64, 64) if size is True else (64 + i, 64 + i)
            shape = (*shape, 3) if img_type == "rgb" else shape
            num_frames = 5 if frames is True else 1 + i
            dtype = f"uint{int(8 * (2**i))}" if dtypes is False else "uint8"
            arr = create_test_array(shape, num_frames, dtype)
            arr_list.append(arr)

        merge_images(arr_list)


preprocess_img_test_matrix = (
    # Image type | Initial dtype | Target dtype | Num frames | Contrast adjustment
    ("gray", "float64", "uint8", 1, "stretch"),
    ("gray", "float64", "uint16", 5, None),
    ("gray", None, "uint32", 1, "harambe"),
    ("gray", "float64", "uint64", 5, "stretch"),  #
    ("gray", "uint8", "int8", 1, "stretch"),
    ("gray", None, "int16", 5, None),
    ("gray", "uint32", "int32", 1, "harambe"),
    ("gray", "paracelsus", "uint64", 5, "stretch"),  #
    ("gray", None, "uint64", 5, "stretch"),  #
    ("rgb", "complex128", "uint8", 1, "stretch"),
    ("rgb", "complex128", "uint16", 5, None),
    ("rgb", None, "uint32", 1, "harambe"),
    ("rgb", "complex128", "uint64", 5, "stretch"),  #
    ("rgb", "int8", "uint8", 1, "stretch"),
    ("rgb", "int16", "uint16", 5, None),
    ("rgb", "int32", "uint32", 1, "harambe"),
    ("rgb", None, "uint64", 5, "stretch"),  #
    ("rgb", "theseus", "uint64", 5, "stretch"),  #
)


@pytest.mark.parametrize("test_params", preprocess_img_test_matrix)
def test_preprocess_img_stk(
    test_params: tuple[Optional[str], Optional[str], str, int, Optional[str]]
):
    def create_test_array(shape, frames, dtype):
        arr = np.reshape(
            np.linspace(0, 2**8 - 1, np.prod((frames, *shape))), (frames, *shape)
        ).astype(dtype)
        return arr

    # Unpack parameters
    img_type, dtype_init, dtype_final, frames, method = test_params
    shape = (64, 64) if img_type == "gray" else (64, 64, 3)

    # Create test array and run it
    dtype_test_arr = dtype_init if dtype_init in known_dtypes else "uint8"
    arr_ref = create_test_array(shape, frames, dtype_test_arr)
    arr_new = preprocess_img_stk(
        array=arr_ref,
        target_dtype=dtype_final,
        initial_dtype=dtype_init,
        adjust_contrast=method,
    )

    # Check that array properties are as expected
    assert arr_ref.shape == arr_new.shape
    assert str(arr_new.dtype) == dtype_final


preprocess_img_fail_cases = (
    # Image type | Initial dtype | Target dtype | Num frames | Contrast adjustment
    # Invalid target dtypes should fail
    ("gray", "float64", "archimedes", 1, "stretch"),
    # Complex arrays with imaginary components should fail
    ("gray", "complex128", "uint8", 1, "stretch"),
)


@pytest.mark.parametrize("test_params", preprocess_img_fail_cases)
def test_preprocess_img_stk_fails(test_params: tuple):
    def create_test_array(shape, frames, dtype):
        arr: np.ndarray = np.reshape(
            np.linspace(0, 2**7 - 1, np.prod((frames, *shape))), (frames, *shape)
        ).astype(dtype)
        return arr

    with pytest.raises((ValueError)):
        # Unpack parameters
        img_type, dtype_0, dtype_1, frames, method = test_params
        shape = (64, 64) if img_type == "gray" else (64, 64, 3)

        # Create test array and run it
        dtype_test = dtype_0 if dtype_0 in known_dtypes else "uint8"
        arr_ref = create_test_array(shape, frames, dtype_test)
        # Add imaginary component for "complex" arrays
        if str(arr_ref.dtype).startswith("complex"):
            arr_ref.imag = create_test_array(shape, frames, "float64")

        preprocess_img_stk(
            array=arr_ref,
            target_dtype=dtype_1,
            initial_dtype=dtype_0,
            adjust_contrast=method,
        )


def test_write_stack_to_tiff():
    pass


def test_write_stack_to_tiff_fails():
    pass
