from __future__ import annotations

from pathlib import Path
from typing import Any, Literal
from unittest import mock
from unittest.mock import MagicMock
from xml.etree.ElementTree import Element, ElementTree

import pytest
from workflows.recipe.wrapper import RecipeWrapper
from workflows.transport.offline_transport import OfflineTransport

from cryoemservices.util.clem_array_functions import write_stack_to_tiff
from cryoemservices.wrappers.clem_align_and_merge import (
    AlignAndMergeParameters,
    AlignAndMergeWrapper,
    align_and_merge_stacks,
)
from tests.test_utils.clem import create_grayscale_image

series_name = "test_series"


@pytest.fixture
def processed_dir(tmp_path: Path):
    processed_dir = tmp_path / series_name
    if not processed_dir.exists():
        processed_dir.mkdir(parents=True)
    return processed_dir


@pytest.fixture
def metadata_file(processed_dir: Path):
    metadata = processed_dir / "metadata" / f"{series_name}.xml"
    if not metadata.parent.exists():
        metadata.parent.mkdir(parents=True)
    if not metadata.exists():
        metadata.touch()
    return metadata


@pytest.fixture
def image_list(processed_dir: Path):
    # Set up test environment
    images: list[Path] = []
    if not processed_dir.exists():
        processed_dir.mkdir(parents=True)

    colors = ("gray", "green", "red")  # Typical colour channels used
    shape = (64, 64)
    num_frames = 5
    dtype = "uint8"

    for c, color in enumerate(colors):
        # Create test image with desired peaks
        arr = create_grayscale_image(
            shape=shape,
            num_frames=num_frames,
            dtype=dtype,
            peaks=[
                {
                    "shape": shape[-2:],
                    "amplitude": 200,
                    "centre": (24 + (2 * c), 24 + (2 * c)),
                    "sigma": (3, 4),
                    "theta": 20,
                    "offset": 0,
                },
                {
                    "shape": shape[-2:],
                    "amplitude": 150,
                    "centre": (40 + (2 * c), 32 + (2 * c)),
                    "sigma": (5, 2),
                    "theta": 40,
                    "offset": 0,
                },
                {
                    "shape": shape[-2:],
                    "amplitude": 100,
                    "centre": (20 + (2 * c), 40 + (2 * c)),
                    "sigma": (5, 2),
                    "theta": 50,
                    "offset": 0,
                },
            ],
            peak_shift_per_frame=(2, -2),
            intensity_offset_per_frame=0,
        )

        # Save image to test environment
        image = write_stack_to_tiff(
            arr,
            save_dir=processed_dir,
            file_name=color,
            x_res=1.0,
            y_res=1.0,
            z_res=1.0,
            units="micron",
            axes="ZYX",
            image_labels=[f"{f}" for f in range(shape[0])],
            photometric="minisblack",
        )
        images.append(image)

    return images


align_and_merge_test_matrix = (
    # Colors | Crop frames | Align self | Flatten | Align across
    (("gray", "green", "red"), 5, "enabled", "max", "enabled"),
    (("gray", "green", "red", "blue"), 5, "enabled", "max", "enabled"),
    (("gray", "green", "red"), 10, "enabled", "mean", "enabled"),
    (("gray", "green", "red"), 5, "", "min", ""),
    (("gray", "green", "red"), None, "enabled", "mean", "enabled"),
    (("gray", "green", "red"), 5, "enabled", "", ""),
    (("green", "red"), 5, "enabled", "max", "enabled"),
    (("green", "red", "blue"), 5, "enabled", "max", "enabled"),
    (("green", "red"), 10, "enabled", "mean", "enabled"),
    (("green", "red"), 5, "", "min", ""),
    (("green", "red"), None, "enabled", "mean", "enabled"),
    (("green", "red"), 5, "enabled", "", ""),
)


@pytest.mark.parametrize("test_params", align_and_merge_test_matrix)
@mock.patch("cryoemservices.wrappers.clem_align_and_merge.parse")
def test_align_and_merge_stacks(
    mock_parse: MagicMock,
    test_params: tuple[
        tuple[str, ...],
        int | None,
        Literal["enabled", ""],
        Literal["min", "max", "mean", ""],
        Literal["enabled", ""],
    ],
    metadata_file: Path,
    image_list: list[Path],
):
    # Unpack test params
    colors, crop_to_n_frames, align_self, flatten, align_across = test_params

    # Mock out the XML metadata variable generated by the 'parse' function
    mock_xml_metadata = MagicMock(spec=ElementTree)
    element_list: list = []
    for color in colors:
        mock_element = MagicMock(spec=Element)
        mock_element.attrib = {"LUTName": color}
        element_list.append(mock_element)
    mock_xml_metadata.findall.return_value = element_list

    mock_parse.return_value.getroot.return_value = mock_xml_metadata

    # Run the function
    result = align_and_merge_stacks(
        image_list,
        metadata_file,
        crop_to_n_frames=crop_to_n_frames,
        align_self=align_self,
        flatten=flatten,
        align_across=align_across,
    )

    # Validate contents of the generated result
    assert set(result["image_stacks"]) == {str(file) for file in image_list}
    assert result["align_self"] == align_self
    assert result["flatten"] == flatten
    assert result["align_across"] == align_across
    output_file = Path(result["output_file"])
    assert output_file.exists()
    thumbnail = output_file.parent / ".thumbnails" / f"{output_file.stem}.png"
    assert result["thumbnail"] == str(thumbnail)
    assert result["thumbnail_size"] == (512, 512)


align_and_merge_wrong_params = (
    # Colors | Crop frames | Align self | Flatten | Align across
    (("gray", "green", "red"), "5", "enabled", "max", "enabled"),
    (("gray", "green", "red"), 5.0, "enabled", "mean", "enabled"),
    (("gray", "green", "red"), 5, None, "min", ""),
    (("gray", "green", "red"), None, 1, "mean", "enabled"),
    (("gray", "green", "red"), 5, "enabled", None, ""),
    (("green", "red"), 5, "enabled", 1, "enabled"),
    (("green", "red"), 10, "enabled", True, "enabled"),
    (("green", "red"), 5, "", "min", None),
    (("green", "red"), None, "enabled", "mean", True),
    (("green", "red"), 5, "enabled", "", 1),
)


@pytest.mark.parametrize("test_params", align_and_merge_wrong_params)
@mock.patch("cryoemservices.wrappers.clem_align_and_merge.parse")
def test_align_and_merge_stacks_wrong_params(
    mock_parse: MagicMock,
    test_params: tuple[
        tuple[str, ...],
        Any,
        Any,
        Any,
        Any,
    ],
    image_list,
    tmp_path,
):
    # Unpack test params
    colors, crop_to_n_frames, align_self, flatten, align_across = test_params

    # Set up the test environment
    processed_dir = tmp_path / series_name
    if not processed_dir.exists():
        processed_dir.mkdir(parents=True)
    metadata = processed_dir / "metadata" / f"{series_name}.xml"
    if not metadata.exists():
        metadata.parent.mkdir(parents=True)
        metadata.touch()

    # Mock out the XML metadata variable generated by the 'parse' function
    mock_xml_metadata = MagicMock(spec=ElementTree)
    element_list: list = []
    for color in colors:
        mock_element = MagicMock(spec=Element)
        mock_element.attrib = {"LUTName": color}
        element_list.append(mock_element)
    mock_xml_metadata.findall.return_value = element_list

    mock_parse.return_value.getroot.return_value = mock_xml_metadata

    # Run the function
    with pytest.raises(ValueError):
        align_and_merge_stacks(
            image_list,
            metadata,
            crop_to_n_frames=crop_to_n_frames,
            align_self=align_self,
            flatten=flatten,
            align_across=align_across,
        )


align_and_merge_parameters_test_matrix = (
    # Number of images | Stringify list | Frames to crop | Align self | Flatten | Align across
    (3, False, 5, "enabled", "max", "enabled"),
    (3, True, 5, "", "mean", "enabled"),
    (3, False, None, "enabled", "min", ""),
    (3, False, "None", "enabled", "min", ""),
    (1, False, 5, "", "", "enabled"),
    (1, True, 5, "enabled", "max", "enabled"),
    (1, False, None, "", "mean", ""),
    (1, False, "None", "", "mean", ""),
)


@pytest.mark.parametrize("test_params", align_and_merge_parameters_test_matrix)
def test_align_and_merge_parameters(
    test_params: tuple[
        int,
        bool,
        int | None,
        str,
        str,
        str,
    ],
    metadata_file: Path,
    image_list: list[Path],
):
    # Unpack test parameters
    num_imgs, stringify, crop_to_n_frames, align_self, flatten, align_across = (
        test_params
    )

    images = image_list[:num_imgs] if num_imgs > 1 else image_list[0]
    if stringify:
        images = (
            str([str(file) for file in images])
            if isinstance(images, list)
            else str(images)
        )

    # Construct the message to submit for testing
    params_dict = {
        "series_name": series_name,
        "images": images,
        "metadata": str(metadata_file),
        "crop_to_n_frames": crop_to_n_frames,
        "align_self": align_self,
        "flatten": flatten,
        "align_across": align_across,
    }

    # Check that validated parameters are of the allowed types/values
    validated_params = AlignAndMergeParameters(**params_dict)
    assert isinstance(validated_params.series_name, str)
    assert isinstance(validated_params.images, list)
    for file in validated_params.images:
        assert isinstance(file, Path)
    assert isinstance(validated_params.metadata, Path)
    assert (
        isinstance(validated_params.crop_to_n_frames, int)
        or validated_params.crop_to_n_frames is None
    )
    assert validated_params.align_self in ("enabled", "")
    assert validated_params.flatten in ("mean", "min", "max", "")
    assert validated_params.align_across in ("enabled", "")


# Set up a mock transport object
@pytest.fixture
def offline_transport(mocker):  # 'mocker' is a keyword associated with unittest.mock
    transport = OfflineTransport()
    mocker.spy(transport, "send")  # Observe what happens to the 'send' call
    return transport


# Patches are matched on a last in, first out basis
@mock.patch("workflows.recipe.wrapper.RecipeWrapper.send_to")  # = mock_send_to
@mock.patch(
    "cryoemservices.wrappers.clem_align_and_merge.align_and_merge_stacks"
)  # = mock_align_and_merge
def test_align_and_merge_wrapper(
    mock_align_and_merge: MagicMock,
    mock_send_to: MagicMock,
    metadata_file: Path,
    image_list: list[Path],
    offline_transport,  # Fixture defined above
):
    # Construct a dictionary to pass to the wrapper
    crop_to_n_frames = 30
    align_self = "enabled"
    flatten = "max"
    align_across = "enabled"

    message = {
        "recipe": {
            "start": [[1, []]],
            "1": {
                "job_parameters": {
                    "series_name": series_name,
                    "images": [str(image) for image in image_list],
                    "metadata": str(metadata_file),
                    "crop_to_n_frames": crop_to_n_frames,
                    "align_self": align_self,
                    "flatten": flatten,
                    "align_across": align_across,
                },
                "parameters": {},
            },
        },
        "recipe-pointer": 1,
        "environment": {"ID": "envID"},
    }

    # Set a recipe wrapper with the correct dictionaries
    recipe_wrapper = RecipeWrapper(message=message, transport=offline_transport)

    # Manually start up the function wrapper
    align_and_merge_wrapper = AlignAndMergeWrapper(recipe_wrapper)
    result = align_and_merge_wrapper.run()

    # Start checking the calls that take place within the function
    # Check the align-and-merge function is called correctly
    mock_align_and_merge.assert_called_once_with(
        images=image_list,
        metadata=metadata_file,
        crop_to_n_frames=crop_to_n_frames,
        align_self=align_self,
        flatten=flatten,
        align_across=align_across,
    )

    # Check that the wrapper sends the correct output message
    # Generate the dictionary to be sent out
    murfey_params = {
        "register": "clem.register_align_and_merge_result",
        "result": mock.ANY,  # Checks that an object exists
    }
    # Check that the message to 'images' is sent correctly
    mock_send_to.assert_any_call(
        "images",
        mock.ANY,
    )
    # Check that message to 'murfey_feedback' is sent correctly
    mock_send_to.assert_any_call(
        "murfey_feedback",
        murfey_params,
    )
    # Check that it was called twice
    assert mock_send_to.call_count == 2

    # Check that the wrapper ran through to completion
    assert result
